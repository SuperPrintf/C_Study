<div align="center">

# **C Language Pointer**</div>

## 1. **关于内存**
* 计算机最关键的组成之一就是随机存取存储器(RAM),是与CPU直接交换数据的内部存储器<br>
* 它用于暂时存放CPU中的运算数据,并作为CPU高速总线向存储等低速设备之间的数据交换媒介<br>
* 既可向指定单元存入信息又可从指定单元读出信息<br>
* 任何RAM中存储的信息在断电后均会丢失，所以RAM是易失性存储器<br>
* 内存中每一个单元即位(bit)只能存储两种状态其中一种(0 or 1)即二进制<br>
* **内存通过地址来进行寻址,编码从0开始到总容量为止**<br>
* 每一个寻址单位大小为1字节(Byte)即8位(bit)<br>
* 内存地址的寻址范围与系统位相关,因此指针通常与`usingned int`数据类型等价(即存储的二进制位数等于系统位数,64位机上等价long)<br>
* 例如32位机可寻址2^32(4G)个地址,64位机可寻址2^64个地址<br>
![内存部件](https://github.com/SuperPrintf/C_Study/blob/main/img/RAM.jpeg "DDR内存条")
## 2. **指针的含义**
* 指针类型不是一个独立的类型,它是一类拥有指针特性变量的统称<br>
* 指针的作用是指向`计算机内存`中的某个空间,因此指针也是一种整型变量(代表目标地址在内存中的)<br>
* 所有变量类型(包括指针类型)都可以有自己类型的指针<br>
* 所有的数组都是指针<br>
* 指针指向的目标地址可以间接的调用,即通过地址来找到相应数据而非直接访问数据<br>
* 由于指针是变量,因此它指向的地址可以随时改变,具有灵活性<br>
* 指针虽然只指向一个地址,但是指针拥有加减运算符,可以访问连续空间<br>
## 3. **指针的使用**
* 指针的变量声明通过`[type] *`的形式表示，该指针的类型即为相应的type *类型<br>
* **指针使用样例**<br>
```C
#include <stdio.h>

int main(int argc, char **argv){
    int* p = NULL;
    int s = 0;
    int nums[] = {1, 2, 3};

    p = nums;
    printf("p = %p, p + 1 = %p\n", p, p + 1);
    printf("width of int type = %lu, (p + 1) - p = %ld\n"
    , sizeof(int), (long)(p + 1) - (long)(p));
    s = *(p + 1);
    printf("p = %p, *p + 1 = %d\n", p, s);

    p = &s;
    printf("p = %p, s = %d\n", p, s);
    *p = 20;
    printf("p = %p, s = %d\n", p, s);
}
```
* 语句解析<br>
    1. _int* p = NULL;_<br>
        * `int *`表示声明了一个int类型的指针,因此p变量的类型为 int *<br>
        * 此处的符号`*`与乘法运算符`*`是同一个字符,但是是完全不同的运算符,此处是类型的表达<br>
        * 声明所有指针时必须初始化!否则可能会指向未知地址导致严重的内存问题!<br>
        * 对于所有指针变量都可以初始化一个值即`NULL`<br>
        * `NULL`是C语言关键字,表示指针未指向任何空间<br>
        * 本句完整含义即为:声明一个 int * 类型的变量p,其值为'空'(NULL)<br>
    2. _int nums[] = {0, 1, 2};_<br>
        * 声明int类型的数组,长度自动推断为3,以列表的方式将其赋值为\[1, 2, 3\]<br>
        * 数组本身是一个指针类型的常量,其指向编译器在栈中申请到的数组空间(连续的3个int数据空间)<br>
        * 多数数据类型并非只有一个字节的长度,而是由多个连续的字节组成,例如`int`的数据长度是4字节<br>
        * 指针本身只代表一个地址的位置(即只会指向一个byte),而指针的类型则告诉编译器这个指针所指数据的宽度<br>
        * `nums`的隐式类型为`const int *`类型,其为不可改变的指针类型,即'nums'指向数组起始地址且永不改变<br>
    3. _p = nums;_<br>
        * 数组所用的下标`[]`其本质是一个指针寻址且解引的符号,int数组解引用后是一个int,若不解引用则为一个指针<br>
        * `nums[]`本身是一个数组,而`nums`作为变量依然有效,是一个指向数组首地址的指针<br>
        * 指针变量p依然是一个变量,因此可以对其进行赋值<br>
        * C语言是弱类型语言因此程序员必须保证右值是一个有效且同类型的数据<br>
        * 现在`p`指针指向了`nums`数组的首地址<br>
    4. _s = *(p + 1);_<br>
        * '*'运算符除了上述作为乘号和表示指针外还用作`解引用`<br>
        * 解除引用后,编译器将按照指针的类型为指示将所指向地址的数据以该类型进行解析<br>
        * 指针拥有`+` `-`的运算属性,`p + 1`表示p指针指向地址的下一地址<br>
        * 由于p的数据类型`为int *`则对其解释时将以从p开始的4个连续字节解释为`int`,同时其`+` `-`运算符也以**该数据类型的宽度**进行计算<br>
        * 指针的加减运算体现了指针`类型`的重要性,所有的指针类型数据本质都是`usigned int`(64位机等价`long`),而指针的类型则隐含了编译器如何解析指针<br>
        * `*(p + 1)`表示对`p + 1`进行解引用,获取到p指针指向的下一地址的值,对`int *`类型的数据解引用得到了`int`类型的数据<br>
        * 该语句的执行结果是将nums数组的第二个数据赋值给s,其等价于`s = nums[1];`<br>
    5. _printf("p = %p, p + 1 = %p", p, p + 1);_<br>
        * %p是指针类型的格式转换符,输出格式为16进制表现<br>
        * 指针类型的本质是一个整型数据,表示目标地址在内存中的位置(编号)<br>
        * p是`int *`类型的指针,p + 1表示p指针指向int地址下一int的地址<br>
    6. _printf("width of int type = %lu, (p + 1) - p = %ld", sizeof(int), (long)(p + 1) - (long)(p));_<br>
        * 通过`sizeof`可以求出类型宽度,`sizeof()`函数传入参数为类型名或变量,返回值类型为'usigned long'表示所占字节数<br>
        * 改代码输出结果显示:`int类型`的宽度为4字节,`int *`类型的p指针的寻址宽度也为4字节<br>
        * 指针通过加减运算的方式可实现对于数据的快速寻址<br>
    7. _p = &s;_<br>
        * `&`运算符也是一个多含义运算符,作为双目运算符时表示按位与,作为单目运算符时表示取地址<br>
        * `&`运算符对s变量取地址之后将会返回一个`int *`类型的值<br>
        * 本句中p获取到了s变量的地址,因此p变量可以间接的操作s变量<br>
    8. _*p = 20;_<br>
        * 此处体现了`*`运算符的第三个作用:作为单目运算符时对所用数据解引用<br>
        * 此时p指向s所在的地址,对p解引用等价于直接使用`int类型`的变量`s`<br>
        * 本句通过对p指针的解引用间接的改变了s变量的值,但p的值不变(因为指向的是s的位置,显然位置是不变的)<br>
    9. _printf("p = %p, s = %d\n", p, s);_<br>
        * 通过该句的输出可以体现到
            * p值在解引用时的值不会出现任何改变,因为操作是p所指向地址的数据,而地址本身是不受任何影响的<br>
            * `*p`以地址访问的形式间接的改变了变量`s`的值<br>
**至此相信你已经学会了关于指针的基本信息,了解了如何对指针进行声明及调用**<br>
**后续将会更加深入的剖析指针与数组的关系、堆与栈、函数传参等更多的指针使用方法,敬请期待**<br>
**关于指针的定义相关知识到这里就结束了,希望本篇文档对你有所帮助**<br>
